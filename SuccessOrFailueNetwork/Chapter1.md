# 1장 웹 브라우저가 메세지를 만든다

### 1.  Http 리퀘스트 메시지를 작성한다

1. 탐험여행은 URL 입력부터 시작

   - HTTP, FTP, FILE, mailto
     - 액세스할 때의 프로토콜 종류
     - ex) HTTP → 웹서버 접근, FTP → File 업로드하거나 다운받는 프로토콜

2. 브라우저는 URL을 해독

3. 파일명을 생략한 경우

   - URL 명을 다음과 같이 ‘/’로 작성해도 무방

     > http://www.example.com/dir/

   - 그러나 파일명을 쓰지 않으면 해당 웹 서버의 어느 파일에 엑세스 할 지 모름

   - → 대부분의 서버가 ‘index.html’로 설정

   - 따라서 파일명을 생략하면 위의 경로는 아래의 경로로 접근

     > http://www.example.com/dir/index.html

4. HTTP 프로토콜의 기본개념

   - 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것
   - 리퀘스트
     - ‘무엇’
       - URI
         - 페이지 데이터를 저장한 파일 이름 또는 CGI 프로그램의 파일명
         - ex : ‘/dir1/file1.html’ or ‘/dir1/program1.cgi’
       - URL 자체를 의미하기도 함
     - ‘어떻게 해서’
       - Method
         - GET
         - POST
         - PUT
         - DELETE
         - HEAD
         - TRACE
   - 리스폰스
     - Status Code

5. HTTP 리퀘스트 메시지를 만든다.

### 2. IP주소를 DNS 서버에 조회한다.

### 1. IP 주소의 기본

- HTTP 메시지를 만들면 다음에는 이것을 OS에 의뢰하여 액세스 대상의 웹서버에게 송신한다.

- 브라우저는 URL을 해독하거나 HTTP 메시지를 만들뿐, 메시지 자체를 네트워크에 송출하는 기능은 없다.

  CF) 메시지 송신기능

  > 메시지를 송신하는 기능은 모든 어플리케이션에 공통이므로 OS가 이 기능을 가지고 있으며, 애플리케이션은 OS에 의뢰하는 것이 현명하다.

### TCP/IP 의 기본 개념

- ‘**서브넷’**이라는 작은 네트워크를 ‘라우터’로 접속하여 전체 네트워크가 만들어짐
  - ‘서브넷’ → ‘허브’에 몇 대의 PC가 접속된 것
  - ‘허브’ → 동에 해당
  - ‘PC’ → 번지에 해당
- ‘동’에 해당하는 번호 → **네트워크 번호**
- ‘번지’에 해당하는 번호 → **호스트 번호**
- 이 둘을 합쳐서 ‘**IP 주소**’

1. 메시지를 송신하면, 서브넷 안에 있는 허브가 패킷을 운반하고 송신측에서 가장 가까운 라우터에 도착
2. 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단하고 송신 후 다시 서브넷의 허브가 라우터까지 메시지를 보내는 동작을 계속하여 반복
3. 최종적으로 데이터가 상대에 도착한다.
   - 실제 IP주소는 32비트 디지털 데이터이고 8비트(1바이트)씩 점으로 구분하여 10진수로 표기
   - BUT, 네트워크 번호와 호스트 번호를 이와 같은 방식으로는 구분 불가
     - ← IP 주소 규칙에서는 두 가지를 합쳐서 32비트로 한다는 것만 결정되어있고 세부 내역은 결정되어 있지않았음.
     - 해당 ‘내역’을 필요에 따라 IP주소에 붙이는데 이것을 ‘**넷마스크**’라고 함
   - Q) ‘넷마스크 표기법’ 구체적으로 이해 안 감
     - 호스트번호 부분의 비트가 전체 0 → 서브넷 자체
     - 호스브번호 부분의 비트가 전체 1 → ‘브로드캐스트’
       - ‘브로드 캐스트’ : 서브넷에 있는 기기 전체에 패킷을 보낸다.

### 2. 도메인명과 IP 주소를 구분하여 사용하는 이유

- URL에 도메인명(서버명)이 아닌 IP주소를 입력해도 정상적으로 동작하지만 숫자를 나열한 IP주소는 기억하기 어렵다는 한계 존재
- 이름으로만 데이터를 운반하면, IP주소가 4바이트만으로 저장가능한데 비해 문자열인 이름은 최소 수십바이트에서 최대 255바이트까지 존재하므로 라우터가 부하되어 데이터 운반동작에 부하가 걸리므로 네트워크 속도가 느려진다.
- 라우터 성능을 향상시킨다 해도 한계가 존재하며 결과적으로 효율성이 좋지 못한 방법이기에 현재와 같이 숫자로 IP주소를 저장한다.
- 따라서 사람은 이름을 사용하고, 라우터는 IP주소를 사용하는데 이 둘의 차이를 해결해주는 것이 **DNS**이다.

### 3. Socket 라이브러리가 IP주소를 찾는 기능을 제공한다.

- 브라우저는 어떻게해서 DNS 서버를 조회할 수 있을까?
  - DNS 서버에 조회한다는 것은 곧 DNS 서버에 조회 메시지를 보내고 거기에 반송하는 응답 메시지를 받는다는 것
  - DNS 클라이언트 → ‘DNS 리졸버’ 또는 리졸버
  - DNS의 원리를 이용하여 IP주소를 조사하는 것 → ‘네임 리졸루션’
- Socket 라이브러리
  - OS에 포함되어있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것
  - 리졸버는 그 속에 들어있는 부품의 하나

### 4. 리졸버를 이용하여 DNS 서버를 조회한다.

- 리졸버의 프로그램명과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출 가능
- C언어로 작성한 네트워크 어플리케이션 소스코드 예시

```java
<애플리케이션 프로그램의 이름>(<매개변수>){
// gethostbyname : 리졸버 프로그램명
///
<메모리 영역> = gethostbyname("www.lab.cyber.co.kr");
///
}
```

### 5. 리졸버 내부의 작동

- 네트워크 애플리케이션(브라우저)가 리졸버를 호출
- 리졸버로 제어권이 넘어가며 애플리케이션의 동작이 일시정지
- 리졸버가 DNS서버에 문의하기 위한 메시지를 생성(브라우저가 생성하는 HTTP Request와 유사)
- 메시지를 DNS서버에 송신
- 메시지 송신 동작은 리졸버가 스스로 실행하는 것이 아니라, OS의 내부에 포함된 프로토콜 스택(TCP/IP 프로토콜 등)을 호출하여 실행
  - 리졸버 또한 브라우저와 마찬가지로 네트워크에 대해 데이터를 송수신하는 기능은 없다.
- 리졸버가 프로토콜 스택을 호출하면 제어가 프로토콜 스택으로 넘어간 후 메시지를 송신한다.
- LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신
- DNS 서버에서 메시지 조회 후 웹 서버가 DNS 서버에 등록되어있다면 응답 메시지를 써서 클라이언트에게 반환
- 해당 메시지는 네트워크를 통해 클라이언트 측에 도달하고 프로토콜 스택을 경유하여 리졸버에 건네져서 리졸버가 내용을 해독한 후 IP 주소를 추출
- 메모리영역에 IP주소를 저장되며 애플리케이션에 건네진다.

### 3. 전 세계의 DNS 서버가 연대한다

### 1. DNS 서버의 기본 동작(책을 통해 그림을 보며 이해하는 편이 좋음)

- DNS 서버의 기본동작은 클라이언트에서 조회 메시지를 받고 조회의 내용을 응답하는 형태로 정보를 회답하는 일
- DNS 조회메시지의 포함사항

1. 이름
   - 서버나 메일 배송 목적지(메일 주소에서 @ 뒷부분의 이름)와 같은 이름
2. 클래스
   - DNS 구조를 고안했을 때 인터넷 이외의 네트워크까지 검토하여 식별하기 위해서 고안되었으나 인터넷 이외의 프로토콜이 없으므로 ‘IN’이 기본값
3. 타입
   - 이름에 어떤 타입의 정보가 지원되는지를 나타낸다.
   - IP주소 조회 시에는 ‘A’ 타입을 사용, 메일 배송 목적지 조회 시에는 ‘MX’타입 사용
   - 타입에 따라 크라이언테에 회답하는 정보의 내용이 달라짐

→ DNS 서버는 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답

타입은 A, MX 말고 다양하게 존재하고 이름, 클래스, 타입 모두 다 일치하는 ‘리소스 레코드’를 조사하여 클라이언트에 회답한다.=

### 2. 도메인의 계층(책을 통해 그림을 보며 이해하는 편이 좋음)

- 인터넷에는 막대한 서버의 수가 있으므로 전부 1대의 DNS 서버에 등록하는 것은 불가능

- 따라서 조회 메세지를 받은 DNS 서버에 정보가 등록되어 있지 않은 경우도 존재

- 해결책은?

- → ‘정보를 분산시켜서 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는 지를 찾아내는 구조’

- DNS 서버에 등록한 정보 → 모든 ‘도메인명’이라는 계층적 구조를 가진 이름이 붙여져있음

- ex) 

  www.lab.cyber.com

  - ‘.’이 계층을 구분
  - 오른쪽에 위치한 것이 상위의 계층을 나타냄
  - com → cyber → lab → www
  - 각각은 모두 ‘도메인’

- 계층화된 도메인의 정보를 서버에 등록하는데, **하나의 도메인을 일괄적으로 취급**

- **즉, 한 개의 도메인 정보를 일괄적으로 DNS 서버에 등록하고 도메인 한 대의 정보를 분할하여 복수의 DNS 서버에 등록하는 것은 불가능하다.**

- **단, DNS 서버와 도메인은 항상 1대1이 아니라 한 대의 DNS 서버에 복수 도메인의 정보를 등록할 수 있다. 즉, 한 대의 DNS 서버에 도메인 한 대를 등록한다.**

### 3. 담당 DNS 서버를 찾아 IP 주소를 가져온다

### 4. 프로토콜 스택에 메시지 송신을 의뢰한다.

### 1. 데이터 송수신 동작의 개요

- IP주소를 DNS서버를 통해 얻은 후, 액세스 대상 웹 서버에 메시지를 송신하도록 프로토콜 스택에 의뢰(브라우저뿐 아니라 네트워크를 이용하는 어플리케이션 모두 공통하는 내용)
- 데이터 송수신은 데이터가 양방향으로 흐르는 ‘파이프’를 통해 가능한데, 이 파이프의 출입구가 ‘소켓’. 데이터 송수신 동작은 다음과 같다.

1. 소켓을 만든다.(소켓 작성단계)
2. 서버측의 소켓에 파이프를 연결(접속단계)
3. 데이터를 송수신(송수신단계)
4. 파이프를 분리하고 소켓을 말소(연결 끊기 단계)

- → OS 내부의 프로토콜 스택이 위 단계를 진행하고, 브라우저 등의 어플리케이션은 단지 프로토콜 스택에 의뢰하여 파이프를 연결하거나 데이터를 쏟아붓는다. 즉 단순히 ‘**의뢰**’를 할뿐이다.

### 2. 소켓의 작성단계

- socket이라는 프로그램부품을 마치 함수처럼 호출하여 ‘디스크립터’을 생성하여 애플리케이션은 이것을 받아서 메모리에 기록
  - ‘디스크립터’ → 각각의 소켓을 식별하기 위한 일종의 번호표와 같은 개념

### 3. 파이프를 연결하는 접속단계

- 애플리케이션은 소켓 라이브러리의 ‘connect’를 호출
  - connect의 매개변수 → 디스크립터, IP주소, 포트번호
    - IP주소는 네트워크에 존재하는 각 컴퓨터를 식별하기 위해 각각에 서로 다른 값을 할당한 것
    - 접속동작은 상대측의 소켓에 대해 이루어지므로 소켓을 지정해야하므로 IP주소만으로는 소켓까지 지정불가
    - → ‘포트 번호’를 통해 가능
    - 즉, IP주소와 포트번호 두 가지를 지정해야 어느 컴퓨터의 어느 소켓과 접속할지 분명히 지정 가능
    - 서버 측의 포트번호는 애플리케이션의 종류에따라 미리 결정된 값을 사용한다는 규약이 존재
      - 웹 → 80번, 메일 → 25번
    - 서버에서도 클라이언트측의 소켓번호가 필요하면 어떻게 알 수 있는가에 관한 의문?
      - 클라이언트의 소켓포트번호는 소켓을 만들 때, 프로토콜 스택이 적당한 값을 만들어서 할당하고, 이 값을 프로토콜 스택이 접속 동작을 실행할때 서버 측에 통지
- 상대(서버)와 연결되면, 프로토콜 스택은 연결된 상대의 IP주소나 포트번호 등의 정보를 소켓에 기록하고 이로써 데이터 송 수신이 가능해진다.

### 4. 메시지를 주고받는 송 수신 단계

- Socket 라이브러리를 통해 프로토콜 스택에 의뢰.

1. write(디스크립터, 송신데이터, 송신 데이터 길이)
   - 사용자가 입력한 URL을 바탕으로 HTTP Request 메시지가 송신데이터
   - 프로토콜 스택이 송신데이터를 서버에 송신
   - 서버는 수신동작을 실행하여 받은 데이터의 내용을 조사하고 적절한 처리를 실행한 후 응답 메시지 반송
2. read()
   - 수신한 응답 메시지를 메모리 영역에 저장 → ‘수신 버퍼’
   - 수신 버퍼에 메시지를 저장한 시점에 애플리케이션에 건내줌.

### 5. 연결 끊기 단계에서 송수신이 종료

- Socket 라이브러리의 close 호출
- 응답 메시지의 송신을 완료했을 때, 웹 서버 측에서 연결 끊기 동작을 실행

1. 먼저 서버에서 close를 호출하여 연결을 끊음.
2. 이것이 클라이언트 측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어감
3. **브라우저가 read로 수신동작을 의뢰했을 때, read는 수신한 데이터를 건네주는 대신 송수신 동작이 완료되어 연결이 끊어졌다는 사실을 브라우저에 통지**
4. **브라우저에서 close()를 호출하여 연결 끊기 단계**

